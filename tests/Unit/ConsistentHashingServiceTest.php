<?php

namespace HuubVerbeek\ConsistentHashing\Tests\Unit;

use HuubVerbeek\ConsistentHashing\ConsistentHashingService;
use HuubVerbeek\ConsistentHashing\Exceptions\NoNodesSetException;
use HuubVerbeek\ConsistentHashing\Implementations\CacheGetter;
use HuubVerbeek\ConsistentHashing\Implementations\CacheSetter;
use HuubVerbeek\ConsistentHashing\NodeCollection;
use HuubVerbeek\ConsistentHashing\StorageNode;
use HuubVerbeek\ConsistentHashing\Tests\TestCase;
use Illuminate\Support\Str;

/**
 * @property ConsistentHashingService $service
 * @property NodeCollection $nodesCollection
 */
class ConsistentHashingServiceTest extends TestCase
{
    private ConsistentHashingService $service;

    private ConsistentHashingService $nodeCollection;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->nodesCollection = new NodeCollection([
            new StorageNode(0, 0),
            new StorageNode(90, 1),
            new StorageNode(180, 2),
            new StorageNode(270, 3),
        ]);

        $this->service = (new ConsistentHashingService())->setNodes($this->nodesCollection);
    }

    public function test_get_valid_degree_from_string()
    {
        foreach (range(1, 1000) as $i) {
            $degree = $this->service->getDegree(Str::random(10));

            $this->assertGreaterThanOrEqual(0, $degree);

            $this->assertLessThanOrEqual(360, $degree);
        }
    }

    public function test_get_key_from_min_value()
    {
        $this->executeGetKeyFromMinValueAsserts(['B', 3, 'C' => 4, 'A' => 1], 'A');
    }

    public function executeGetKeyFromMinValueAsserts(array $array, string $expected)
    {
        $key = $this->service->getKeyFromMinValue($array);

        $this->assertEquals($expected, $key);
    }

    public function test_computing_results_based_on_input_degree()
    {
        $this->executeComputingDistancesAsserts(90, [
            0 => -90,
            1 => 0,
            2 => 90,
            3 => 180,
        ], 3);

        $this->executeComputingDistancesAsserts(0, [
            0 => 0,
            1 => 90,
            2 => 180,
            3 => 270,
        ], 4);

        $this->executeComputingDistancesAsserts(360, [
            0 => -360,
            1 => -270,
            2 => -180,
            3 => -90,
        ], 0);
    }

    public function executeComputingDistancesAsserts(float $degree, $expectedResults, $positiveValueCount)
    {
        $positiveValues = [];

        $results = $this->service->computeDistances($this->nodesCollection, $degree, $positiveValues);

        $this->assertEquals($expectedResults, $results);

        $this->assertCount($positiveValueCount, $positiveValues);
    }

    public function test_selection_of_the_next_node()
    {
        $node = $this->service->nextNode(0);

        $this->assertEquals(0, $node->identifier);

        foreach (range(1, 90) as $i) {
            $node = $this->service->nextNode($i);
            $this->assertEquals(1, $node->identifier);
        }

        foreach (range(91, 180) as $i) {
            $node = $this->service->nextNode(($i));
            $this->assertEquals(2, $node->identifier);
        }

        foreach (range(181, 270) as $i) {
            $node = $this->service->nextNode($i);
            $this->assertEquals(3, $node->identifier);
        }

        foreach (range(271, 360) as $i) {
            $node = $this->service->nextNode($i);
            $this->assertEquals(0, $node->identifier);
        }
    }

    public function test_when_no_nodes_are_set_throw_exception()
    {
        $this->expectException(NoNodesSetException::class);

        $this->service->setNodes(new NodeCollection());

        $this->service->nextNode(0);
    }

    public function test_all_values_can_be_set_and_retrieved()
    {
        // Default getter and setter.

        $this->executeGetAndSetAsserts();

        //Cache getter and setter

        $this->service->setNodes(
            new NodeCollection([
                new StorageNode(0, 'file', CacheSetter::class, CacheGetter::class),
                new StorageNode(90, 'file', CacheSetter::class, CacheGetter::class),
                new StorageNode(180, 'file', CacheSetter::class, CacheGetter::class),
                new StorageNode(270, 'file', CacheSetter::class, CacheGetter::class),
            ])
        );

        $this->executeGetAndSetAsserts();
    }

    public function executeGetAndSetAsserts()
    {
        $data = [];

        foreach (range(1, 200) as $i) {
            $key = Str::random(6);
            $value = rand(0, 100);

            $data[$key] = $value;

            $node = $this->service->resolveNode($key);

            $node->set([$key, $value]);
        }

        foreach ($data as $key => $value) {
            $node = $this->service->resolveNode($key);

            $this->assertEquals($value, $node->get([$key]));
        }
    }
}
